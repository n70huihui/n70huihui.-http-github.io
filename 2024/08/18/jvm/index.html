<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="JVM, 热心市民灰灰个人博客">
    <meta name="description" content="个人博客，欢迎访问">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>JVM | 热心市民灰灰个人博客</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>




<body>

    <!-- 动态标签栏 -->
    <script type="text/javascript">
    var OriginTitile = document.title, st; 
    document.addEventListener("visibilitychange", function () { 
      document.hidden ? (document.title = "这就走啦？不打算再看看吗？", clearTimeout(st)) : (document.title = "噫！好！你来啦！", st = setTimeout(function () { document.title = OriginTitile }, 3e3)) }) 
    </script>

    <!--深色模式-->
    <!-- 白天和黑夜主题 -->
<div class="sum-moon-box">
    <a class="btn-floating btn-large waves-effect waves-light" onclick="switchNightMode()" title="切换主题" >
      <i id="sum-moon-icon" class="fas fa-sun" style="width:48px; height:48px; font-size: 28px;"></i>
    </a>
  </div>
  
  <script>
    function switchNightMode() {
      $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
          $('body').hasClass('DarkMode') 
          ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
          : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
          setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
              $(this).remove()
            })
          }, 2e3)
        })
    }
  </script>

<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
  </div>
    <script>
    /* 模式判断 */
    if (localStorage.getItem('isDark') === '1') {
        document.body.classList.add('DarkMode');
        $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')
    } else {
        document.body.classList.remove('DarkMode');
        $('#sum-moon-icon').removeleClass("fa-sun").addClass('fa-moon')
    }
    </script>
    <!--深色模式-->
     
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/loading.gif" data-original="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">热心市民灰灰个人博客</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/loading.gif" data-original="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">热心市民灰灰个人博客</div>
        <div class="logo-desc">
            
            个人博客，欢迎访问
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/JVM.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">JVM</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #576690;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #576690;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Java/">
                                <span class="chip bg-color">Java</span>
                            </a>
                        
                            <a href="/tags/JVM/">
                                <span class="chip bg-color">JVM</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/JVM/" class="post-category">
                                JVM
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2024-08-18
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2024-08-27
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    13.2k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    46 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h2><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ol>
<li><code>javap -v 字节码文件名称</code> 命令：<code>javap</code> 是 JDK 自带的反编译工具，可以通过控制台查看字节码文件的内容。<strong>适合在服务器上查看字节码文件内容。</strong>（末尾加上 <code>&gt; /xxx/xxx.txt</code> 可以把反编译的信息输出到指定文件中）</li>
<li><code>jar -xvf jar包名称</code>：解压 jar 包。</li>
<li>使用 IDEA 自带的 jclasslib 插件时，如果发现代码更改后字节码文件没有变，需要<strong>重新构建项目</strong>。</li>
<li>在 JDK 安装目录下 <code>lib</code> 文件夹中<code>sa-jdi.jar</code> 可以帮助我们查看 JVM 内存信息。高级版本的 JDK 中并没有这个 jar 包，在 <code>bin</code> 目录控制台下输入 <code>jhsdb hsdb</code> 打开。</li>
<li><code>jps</code>：该命令可以把所有运行中的 java 进程信息展示出来。</li>
</ol>
<h3 id="初识-JVM"><a href="#初识-JVM" class="headerlink" title="初识 JVM"></a>初识 JVM</h3><p>JVM 全称是 Java Virtual Machine，<strong>本质是一个运行在计算机上的程序</strong>，它的职责是<strong>运行 Java 字节码文件</strong>。</p>
<p>JVM 的三大核心功能：</p>
<ol>
<li>解释和运行：对字节码文件中的指令，<strong>实时</strong>的解释成机器码（主要是为了支持跨平台特性），让计算机执行。</li>
<li>内存管理：自动为对象、方法等分配内存。自动的垃圾回收机制，回收不再使用的对象。</li>
<li>即时编译（JIT）：对热点代码进行优化，提升运行效率。被翻译成机器码的热点文件会被存储到<strong>内存</strong>中。</li>
</ol>
<p>常见的 JVM 有 HotSpot，GraalVM，OpenJ9 等，另外 DragonWell 龙井 JDK 也提供了一款功能增强版的 JVM。我们平时默认使用的虚拟机是 Oracle 官方的 HotSpot。</p>
<h3 id="Java-虚拟机的组成"><a href="#Java-虚拟机的组成" class="headerlink" title="Java 虚拟机的组成"></a>Java 虚拟机的组成</h3><p>JVM 的组成：</p>
<ol>
<li>类加载器 <code>ClassLoader</code>：作用是把从磁盘上读取的字节码文件加载到内存中。</li>
<li>运行时数据区域：负责管理 JVM 使用到的内存（方法区、堆区）。（例如上述的字节码文件通过类加载器加载后会存放在这个区域中）</li>
<li>执行引擎：包括即时编译器、解释器、垃圾回收器等。负责将字节码文件中的指令解释成机器码，同时使用即时编译器优化性能。</li>
<li>本地接口：用来调用本地已经编译的方法，比如虚拟机中提供的 C/C++ 方法。（虚拟机是使用 C/C++ 编写的，所以一些底层的接口需要调用相关方法）</li>
</ol>
<p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/n70huihui/Blog_Photo/JVM-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E7%BB%84%E6%88%90.png"></p>
<h3 id="字节码文件的组成"><a href="#字节码文件的组成" class="headerlink" title="字节码文件的组成"></a>字节码文件的组成</h3><p><mark>可以使用 <a target="_blank" rel="noopener" href="https://github.com/ingokegel/jclasslib">jclasslib</a> 工具来查看字节码文件。使用 <a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/">Arthas</a> 进行线上监控诊断。</mark></p>
<p>字节码文件主要有五部分：</p>
<ol>
<li>基础信息：魔数、字节码文件对应的 Java 主副版本号、访问标识（public final 等等）、父类和接口。</li>
<li>常量池：保存了字符串常量、类或接口名、字段名。主要在字节码指令中使用。注意，这里的常量池指的是<strong>编译期常量池</strong>（和运行时常量池不一致），可以理解成信息的记录，记录了程序中所有符号和常量的映射。</li>
<li>字段：当前类或接口声明的字段信息。</li>
<li>方法：当前类或接口声明的方法信息，字节码指令。</li>
<li>属性：类的属性，比如源码的文件名内部类的列表等。</li>
</ol>
<p>重要组成部分说明：</p>
<ol>
<li>魔数：在字节码文件中，起始的几个字节固定为 <code>ca fe ba be</code>。而一个文件是<strong>无法通过文件扩展名来确定文件类型</strong>的，文件扩展名是可以随意修改的，不会影响文件内容。我们使用软件打开文件的时候，软件会使用文件的头几个字节（文件头）去校验文件类型，如果该软件不支持这种类型，就会报错。所以字节码文件开头的魔数，就是用来<strong>唯一标定字节码文件类型</strong>的。</li>
<li>主副版本号：指的是编译字节码文件的 JDK 版本号，主版本号用来标识大版本号，JDK 1.0-1.1 使用了<br>45.0 - 45.3，JDK 1.2 是 46。之后每升级一个大版本就加 1；副版本号是当主版本号相同时作为区分不同<br>版本的标识，一般只需要关心主版本号。<strong>版本号的作用主要是判断当前字节码的版本和运行时的 JDK 是否兼容。</strong>（目前，<code>主版本号 - 44</code> 就是对应的 JDK 版本号）</li>
<li>常量池：避免相同内容的重复定义，节省空间。（比如两个字符串变量定义了相同内容，这个时候就会让两个字符串指向同一块空间）字节码在设计时，会根据字段的属性信息先去找常量池中的 <code>String_info</code>，再根据索引去找常量池中的 <code>info</code>（<code>info</code> 字面量的存在是为了当变量名和字符串文本名一致的时候，可以复用，节省空间），此时才是真正存储字符串文本内容的地方。</li>
<li>方法：字节码中的方法区域是存放字节码指令的核心位置，字节码指令的内容存放在方法的 Code 属性中。其中，操作数栈是临时存放数据的地方，局部变量表是存放方法中的局部变量的位置。</li>
</ol>
<h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><p>类的生命周期描述了一个类加载、使用、卸载的整个过程。类的生命周期主要有五个阶段，分别是：加载、连接（连接又包括验证、准备和解析）、<strong>初始化</strong>、使用、卸载。</p>
<ol>
<li><p>加载：类加载器根据类的全限定名通过不同的渠道（磁盘读取，动态代理，网络传输）以二进制流的方式获取字节码信息。程序员可以使用 Java 代码拓展不同的渠道。在类加载器加载完类之后，Java 虚拟机会将字节码中的信息保存到方法区（方法区是虚拟概念，真正的实现有所不同）中，生成一个 <code>InstanceKlass</code> 对象，保存类的所有信息，里面还包含实现特定功能比如多态的信息。除此之外，Java 虚拟机还会在堆中生成一份与方法区中数据类似的 <code>java.lang.Class</code> 对象，作用是在使用反射时可以在 Java 代码中去获取类的信息以及存储静态字段的数据。<code>InstanceKlass</code> 和 <code>java.lang.Class</code> 可以相互关联，<code>InstanceKlass</code> 中信息更丰富，但是有些需要对开发者闭源，并且 <code>InstanceKlass</code> 可以被 C/C++ 操作，是给 JVM 使用的；而 <code>java.lang.Class</code> 是给 Java 开发者使用的。</p>
<p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/n70huihui/Blog_Photo/JVM-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E9%98%B6%E6%AE%B5.png"></p>
</li>
<li><p>连接：连接阶段第一个环节是验证，验证的主要目的是检测 Java 字节码文件是否遵守了 《Java 虚拟机规范》 中的约束。这个阶段一般不需要程序员参与。第二个环节是准备，准备阶段为<strong>静态变量</strong>（static）分配内存并设置初始值（没有 <code>final</code> 修饰的情况下，一般为 0，如果有 <code>final</code> 修饰，则直接赋现有值）。第三个环节是解析，解析阶段主要是将常量池中的符号引用替换为直接引用。</p>
</li>
<li><p>初始化：初始化阶段会执行静态代码块中的代码，并<strong>为静态变量赋值</strong>（这里赋的值就是现有值，而不是初始值，执行的是 <code>clinit</code> 的字节码指令）。以下几种方式会导致类的初始化：</p>
<ol>
<li>访问一个类的静态变量或者静态方法，注意变量是 <code>final</code> 修饰的并且等号右边是常量不会触发初始化（这种在连接阶段就已经赋好值了）。</li>
<li>调用 <code>Class.forName(String className)</code> 时。</li>
<li><code>new</code> 一个该类的对象时。</li>
<li>执行 <code>Main</code> 方法的当前类。</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token comment">// 输出结果: DACBCB</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 1.启动main方法，初始化Main类，先走Main的clinit，执行static代码块，打印D</span>

        <span class="token comment">// 2.打印A</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 3.创建Main对象，调用构造方法，先走构造代码块，再走无参构造，打印CB</span>
        <span class="token keyword">new</span> <span class="token class-name">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 4.重复创建，再次打印CB</span>
        <span class="token keyword">new</span> <span class="token class-name">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"C"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"D"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>clinit</code> 指令在特定情况下不会出现，比如：</p>
<ol>
<li>无静态代码块且无静态变量赋值语句。</li>
<li>有静态变量的声明，但是没有赋值语句。</li>
<li>静态变量的定义使用 <code>final</code> 关键字，这类变量会在准备阶段直接进行初始化。</li>
<li>数组的创建不会导致数组中<strong>元素的类</strong>进行初始化。</li>
</ol>
<p>如果出现继承，则：</p>
<ol>
<li>直接访问父类的静态变量，不会触发子类的初始化。</li>
<li>子类的初始化 <code>clinit</code> 调用之前，会先调用父类的 <code>clinit</code> 初始化方法。</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 输出结果为1</span>
        <span class="token comment">// 因为是直接使用B02的静态变量，这个时候是只走父类的初始化的</span>
        <span class="token comment">// 如果在前面加上 new B02();   那么就会打印2</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token constant">B02</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">A02</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">B02</span> <span class="token keyword">extends</span> <span class="token class-name">A02</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>类加载器（ClassLoader）是 JVM 提供给应用程序去实现获取类和接口字节码数据的技术，只参与<strong>加载过程中的字节码获取并加载到内存</strong>这一部分。通过加载字节码数据放入内存转换成 <code>byte[]</code>，接下来调用虚拟机底层方法将 <code>byte[]</code> 转换成方法区和堆中的数据。</p>
<h4 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h4><p>类加载器分为两类，一类是 Java 代码中实现的，一类是 Java 虚拟机底层源码实现的：</p>
<ul>
<li>虚拟机底层实现：原代码位于 Java 虚拟机的源码中，实现语言与虚拟机底层语言一致，比如 Hotspot 使用 C++。作用是加载程序运行时的基础类，比如 <code>java.lang.String</code>，保证基础类被正确加载。</li>
<li>JDK 中默认提供或者自定义：JDK 中默认提供了多种不同渠道的类加载器，程序员也可以自己根据需求定制。所有 Java 中实现的类加载器都需要继承 <code>ClassLoader</code> 这个抽象类。</li>
</ul>
<p>类加载器的设计 JDK 8 和 8 之后的版本差别较大，JDK 8 及之前的版本中默认的类加载器有如下几种：</p>
<ul>
<li>虚拟机底层实现：启动类加载器 <code>Bootstrap</code> ，用于加载 Java 中最核心的类。</li>
<li>Java：扩展类加载器 <code>Extension</code>，允许扩展 Java 中比较通用的类；应用程序类加载器 <code>Application</code>，加载应用使用的类。</li>
</ul>
<h5 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a>启动类加载器</h5><p>启动类加载器（Bootstrap ClassLoader）是由 Hotspot 虚拟机提供的、使用 C++ 编写的类加载器。由启动类加载器加载的基础类，无法通过 <code>.class.getClassLoader()</code> 来获取类加载器，因为这种方法获取的类加载器是 Java 的类加载器，而并非虚拟机底层的类加载器。</p>
<p>如果要对核心类进行扩展，可以通过启动类加载器去加载用户 jar 包。可用的方法是使用参数进行扩展，在 IDEA 的运行调试配置中添加 <code>-Xbootclasspath/a:jar包目录/jar包名</code> 来进行扩展。</p>
<h5 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h5><p>扩展类加载器和应用程序类加载器都是 JDK 中提供的、使用 Java 编写的类加载器。它们的源码都位于 <code>sun.misc.Launcher</code> 中，是一个静态内部类。继承自 <code>URLClassLoader</code>。具备通过目录或者指定 jar 包将字节码文件加载到内存中。在 JDK 8 中主要用来加载 java 安装目录下 <code>/jre/lib/ext</code> 下的扩展类文件。</p>
<p>扩展类加载器主要加载扩展功能（有些功能我们平时并不常用）。如果我们需要编写一些通用但是不常用的 jar 包，可以通过扩展类加载器来进行加载。在 JDK 8 中可以使用 <code>-Djava.ext.dirs="原始jar包目录;新增jar包目录"</code> 进行扩展。</p>
<h5 id="应用程序类加载器"><a href="#应用程序类加载器" class="headerlink" title="应用程序类加载器"></a>应用程序类加载器</h5><p>应用程序类加载器主要用来加载 <code>classpath</code> 下的类文件，包括了我们自己编写的 java 文件以及第三方库中的类文件。</p>
<h4 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h4><p>由于 Java 虚拟机中有多个类加载器，双亲委派机制的核心是解决一个类到底由谁加载的问题。双亲委派机制的作用是：</p>
<ol>
<li>保证类加载的安全性：通过双亲委派机制避免恶意代码替换 JDK 中的核心类库，比如 <code>java.lang.String</code>，确保核心类库的完整性和安全性。</li>
<li>避免重复加载：双亲委派机制可以避免同一个类被多次加载。</li>
</ol>
<p>双亲委派机制指的是：当一个类加载器接收到加载类的任务时，会自底向上查找是否加载过，再由顶向下进行加载。（由顶向下：启动类加载器、扩展类加载器、应用程序类加载器）</p>
<p>每个类加载器都有一个父类加载器，在类加载的过程中，每个类加载器都会先检查是否已经加载了该类，如果已经加载则直接返回，避免重复加载。否则会将加载请求委派给父类加载器。如果所有的父类加载器都无法加载该类，则由当前类加载器自己尝试加载。所以看上去是自顶向下尝试加载。</p>
<p><code>ClassLoader</code> 中包含了 4 个核心方法：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 类加载的入口，提供了双亲委派机制，内部会调用findClass</span>
<span class="token keyword">public</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 由类加载器子类实现，获取二进制数据调用defineClass，比如URLClassLoader会根据文件路径去获取类文件中的二进制数据</span>
<span class="token keyword">protected</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">findClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 做一些类名的校验，然后调用虚拟机底层的方法将字节码信息加载到虚拟机内存中</span>
<span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">defineClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> off<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 执行类声明周期中的连接阶段</span>
<span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">resolveClass</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="打破双亲委派机制"><a href="#打破双亲委派机制" class="headerlink" title="打破双亲委派机制"></a>打破双亲委派机制</h4><p>打破双亲委派机制的方法有三种：</p>
<ol>
<li><p>自定义类加载器：自定义类加载器并重写 <code>loadClass</code> 方法，就可以将双亲委派机制的代码去除。Tomcat 通过这种方式实现应用之间的类隔离。</p>
<p>一个 Tomcat 程序中是可以运行多个 Web 应用的，如果这两个应用中出现了相同限定名的类，比如 Servlet 类，Tomcat 要保证这两个类都能加载并且它们应该是不同的类。如果不打破双亲委派机制，当应用类加载器加载 Web 应用 1 中的 <code>MyServlet</code> 之后，Web 应用 2 中相同限定名的 <code>MyServlet</code> 类就无法被加载了。所以，Tomcat 使用了自定义类加载器来实现应用之间类的隔离，每一个应用会有一个独立的类加载器加载对应的类。</p>
</li>
<li><p>线程上下文类加载器：利用上下文类加载器加载类，比如 JDBC 和 JNDI 等。</p>
<p>JDBC 中使用了 <code>DriverManager</code> 来管理项目中引入的不同数据库的驱动，比如 mysql 驱动、oracle 驱动。<code>DriverManager</code> 类位于 <code>rt.jar</code> 包中，由启动类加载器来加载。而我们自己引入的数据库驱动是由应用程序类加载器来加载，这违反了双亲委派机制（按照双亲委派机制的正常逻辑，<code>DriverManager</code> 类无法直接访问由应用程序类加载器加载的 JDBC 驱动类，因为类加载器通常只会访问自己或祖先加载器加载的类。但在 JDBC 场景中，<code>DriverManager</code> 却可以访问这些由应用程序类加载器加载的驱动类）。</p>
<p>JDBC 是如何实现这种 “违反” 双亲委派机制的操作呢？首先，我们先来解决一个问题，就是：<code>DriverManager</code> 是如何知道 <code>jar</code> 包中要加载的驱动在哪儿的？实际上，JDBC 采用了 JDK 内置的 SPI（Service Provider Interface） 机制：在 <code>classpath</code> 路径下的 <code>META-INF/servies</code> 文件夹中，固定暴露了驱动接口文件，接着，在 <code>DriverManager</code> 的代码中，使用 <code>ServiceLoader</code> 来加载驱动。</p>
<p>观察加载过程我们发现，<strong>驱动文件确实是由应用程序类加载器来加载的</strong>，那么，SPI 中是又是如何获取到应用程序类加载器的呢？实际上，SPI 中使用了线程上下文中保存的类加载器进行类加载（<code>Thread.currentThread().getContextClassLoader()</code>），而被保存的这个类加载器一般是应用程序类加载器。</p>
<p>不过，JDBC 只是在 <code>DriverManager</code> 加载完之后，通过初始化阶段触发了驱动类的加载，类的加载依旧遵循双亲委派机制，所以，从这个角度上看，<mark>JDBC 的驱动加载并不会真正打破双亲委派机制</mark>。</p>
</li>
<li><p>Osgi 框架的类加载器：历史上 Osgi 框架实现了一套新的类加载器机制，允许同级之间委托进行类的加载。Osgi 还是用类加载器实现了热部署（指在服务不停止的情况下，动态更新字节码文件到内存中）的功能。不过，现如今我们可以使用 Arthas 来帮助我们进行热部署，基本步骤如下：</p>
<ol>
<li>在服务器上部署 arthas，并启动。</li>
<li><code>jad --source-only 类全限定名 &gt; 目录/文件名.java</code>，利用 <code>jad</code> 命令反编译，然后可以用其他编译器，比如 vim 来修改源码。</li>
<li><code>sc -d 类全限定名</code>，利用 <code>sc</code> 命令查看类对应的类加载器 hashcode。</li>
<li><code>mc -c 类加载器的hashcode 目录/文件名.java -d 输出目录</code>，使用 <code>mc</code> 命令来编译修改过的代码。</li>
<li><code>retransform class文件所在目录/xxx.class</code>，用 <code>retransform</code> 命令加载新的字节码。</li>
<li>注意事项：程序重启之后，字节码文件会恢复（因为 <code>retransform</code> 是做内存上的更新），除非将 class 文件放入 jar 包中进行更新。并且，<code>retransform</code> 也不能添加方法或者字段，也不能更新正在执行中的方法。</li>
</ol>
</li>
</ol>
<h4 id="JDK-9-之后的类加载器"><a href="#JDK-9-之后的类加载器" class="headerlink" title="JDK 9 之后的类加载器"></a>JDK 9 之后的类加载器</h4><p>JDK 8 及之前的版本中，扩展类加载器和应用程序类加载器的源码位于 <code>rt.jar</code> 包中的 <code>sun.misc.Launcher.java</code>。</p>
<p>由于 JDK 9 引入了 module 的概念，类加载器在设计上发生了很多变化：</p>
<ol>
<li>启动类加载器使用 Java 编写，位于 <code>jdk.internal.loader.ClassLoader</code> 类中。Java 中的 <code>BootClassLoader</code> 继承自 <code>BuiltinClassLoader</code>，实现从模块中找到要加载的字节码资源文件。启动类加载器依然无法通过 java 代码获取到，返回的仍然是 null，保持了统一。</li>
<li>扩展类加载器被替换成了平台类加载器（Platform Class Loader），平台类加载器遵循模块化方式加载字节码文件，所以继承关系从 <code>URLClassLoader</code> 变成了 <code>BuiltinClassLoader</code>，实现了从模块中加载字节码文件。平台类加载器的存在更多的是为了与老版本的设计方案兼容，<strong>自身没有特殊逻辑</strong>。</li>
<li>应用程序类加载器的继承关系发生了改变，从 <code>URLClassLoader</code> 变成了 <code>BuiltinClassLoader</code>，其余没有特殊变化。</li>
</ol>
<h3 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h3><p>运行时数据区域包括两大区域，一种是线程不共享区，包括了程序计数器、Java 虚拟机栈、本地方法栈；另一种是线程共享区，包括了方法区、堆区。</p>
<h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>程序计数器（Program Counter Register），也叫 PC 寄存器，是线程不共享的。每个线程会通过程序计数器记录当前要执行的字节码指令的地址。</p>
<p>程序计数器可以控制程序指令的进行，实现分支、跳转、异常等逻辑。在多线程执行情况下，Java 虚拟机需要通过程序计数器记录 CPU 切换前解释执行到哪一句指令并继续解释执行。</p>
<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><h5 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h5><p>Java 虚拟机栈（Java Virtual Machine Stack）采用栈的数据结构来管理方法调用中的基本数据，先进后出（First In Last Out），每一个方法的调用使用一个栈帧（Stack Frame）来保存。</p>
<p>Java 代码在遇到异常，报错的时候，会把异常时的栈帧信息打印出来。也就是说，发生异常时，控制台上打印出来的，是栈帧信息。</p>
<p>Java 虚拟机栈中，主要由三个部分组成：</p>
<ol>
<li>局部变量表：其作用是在运行过程中存放所有的局部变量。编译成字节码文件时可以就确定局部变量表的内容。实际栈帧中的局部变量表是一个数组，数组中每一个位置称为一个槽（slot），<code>long</code> 和 <code>double</code> 类型占用两个槽，其他类型占用一个槽。在字节码文件记录的局部变量表信息中，<code>Nr.</code> 表示局部变量的编号，<code>起始PC</code> 和 <code>长度</code> 划定了局部变量生效的范围，<code>序号</code> 表示槽的起始编号。实例方法中，序号为 0 的地方存放的是 <code>this</code>，指的是当前调用方法的对象。为了节省空间，局部变量表中的槽是可以复用的，一旦某个局部变量不再生效，当前槽就可以再次被使用。</li>
<li>操作数栈：操作数栈是栈帧中虚拟机在执行指令过程中用来存放临时数据的一块区域。在<strong>编译期</strong>就可以确定操作数栈的最大深度，从而在执行时正确的分配内存大小。</li>
<li>帧数据：主要包含动态链接、方法出口、异常表的引用。当前类的字节码指令引用了其他类的属性或者方法时，需要将符号引用（编号）转换成对应的运行时常量池中的内存地址。动态链接就保存了编号到运行时常量池的内存地址的映射关系。而方法出口，就是记录的调用一个方法后，程序计数器应该返回的地址（与汇编语言中的返回地址压栈类似）。最后，异常表存放的是代码中异常的处理信息，包含了异常捕获的生效范围以及异常发生后跳转到的字节码指令位置。</li>
</ol>
<p>每一个栈帧都是有限的，如果栈帧过多，占用内存超过栈内存可以分配的最大大小就会出现内存溢出，出现 <code>StackOverflowError</code> 的错误。虚拟机设置中，可以使用 <code>-Xss栈大小</code> 来设置栈帧最大大小，不过<strong>必须是 1024 的倍数</strong>。Windows（64 位）下的 JDK 8 测试最小值为 180 K，最大值为 1024 M。一般来说，工作中即使使用了递归进行操作，栈的深度最多也只能到几百，不会出现栈的溢出。所以此参数可以手动指定为 <code>-Xss256k</code> 来节省内存。</p>
<h5 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h5><p>除了 Java 虚拟机栈，栈区还包括有本地方法栈。Java 虚拟机栈存储了 Java 方法调用时的栈帧，而本地方法栈存储的是 native 本地方法的栈帧。在 Hotspot 虚拟机中，<strong>Java 虚拟机栈和本地方法栈实现上使用了同一个栈空间</strong>。本地方法栈会在栈内存上生成一个栈帧，临时保存方法的参数同时方便出现异常时也把本地方法的栈信息打印出来。</p>
<h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>一般 Java 程序中堆内存是空间最大的一块内存区域。创建出来的对象都存在于堆上。栈上的局部变量表中，可以存放堆上对象的引用。静态变量也可以存放堆对象的引用，通过静态变量就可以实现对象在线程之间共享。堆内存大小是有上限的，当对象一直向堆中放入对象达到上限之后，就会抛出 <code>OutOfMemory</code> 错误。</p>
<p>堆空间有三个需要关注的值：used、total、max。used 指的是当前已使用的堆内存，total 是 java 虚拟机已经分配的可用堆内存，max 是 java 虚拟机可以分配的最大堆内存。随着堆中的对象增多，当 total 可以使用的内存即将不足时，java 虚拟机会继续分配内存给堆。然而，<mark>并不是当 <code>used = max = total</code> 时，堆内存才溢出。</mark>堆内存溢出的判断条件比较复杂，在后续的垃圾回收章节会继续详细介绍。</p>
<p>如果不设置任何的虚拟机参数，max 默认是系统内存的四分之一，total 默认是系统内存的六十四分之一。在实际应用中一般都需要设置 total 和 max 的值。使用 <code>-Xmx</code> 修改 max 值（必须大于 2 M），<code>-Xms</code> 修改 total 值（必须大于 1 M）。在服务端程序开发时，建议将 max 值和 total 值设置为相同的值，这样在程序启动之后可使用的总内存就是最大内存，而无需向 JVM 再次申请，减少了申请空间时的额外开销。</p>
<p>需要注意的是，如果使用 Arthas 显示 heap 堆大小，会发现其和设置的值并不相同。这是因为 Arthas 使用的是 JMX 技术中的内存获取方式，这种方式与垃圾回收器有关，计算的是可以分配对象的内存，而不是整个内存。</p>
<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>方法区是 《Java 虚拟机规范》 中设计的虚拟概念，每款虚拟机设计各不相同。Hotspot 设计如下：</p>
<ul>
<li>JDK 7 及之前的版本将方法去存放在<strong>堆区域中</strong>的永久代空间中，堆的大小由虚拟机参数 <code>-XX:MaxPermSize=值</code> 控制。</li>
<li>JDK 8 及之后的版本将方法区存放在<strong>元空间</strong>中，元空间位于操作系统维护的<strong>直接内存</strong>中，默认情况下只要不<br>超过操作系统承受的上限，可以一直分配。可以使用 <code>-XX:MaxMetaspaceSize=值</code> 将元空间最大大小进行限制。</li>
</ul>
<p>方法区是存放基础信息的位置，线程共享，主要包含三个内容：</p>
<ol>
<li>类的元信息：在类的加载阶段，会在方法区生成 <code>InstanceKlass</code> 对象，存放了字节码文件的基本信息。</li>
<li>运行时常量池：字节码文件中通过编号查表的方式找到常量，这种常量池称为静态常量池。当常量池加载到内存中之后，可以通过内存地址快速的定位到常量池中的内容，这种常量池称为运行时常量池。</li>
<li>字符串常量池：字符串常量池存储在代码中定义的常量字符串内容。早期设计时，字符串常量池是属于运行时常量池的一部分，他们存储的位置也是一致的。后续做出了调整，将字符串常量池和运行时常量池做了拆分。<mark>JDK 7 之前，运行时常量池逻辑包含字符串常量池，hotspot 虚拟机对方法区的实现为永久代；JDK 7 时，字符串常量池被从方法区拿到了堆中，运行时常量池剩下的东西还在永久代；JDK 8 之后 hotspot 移除了永久代，用处于直接内存中的元空间取而代之，字符串常量池还在堆区中。可以使用 <code>intern</code>&nbsp;方法主动把字符串放到字符串常量池中，JDK 6 版本的 <code>intern</code>&nbsp;方法会把第一次遇到的字符串实例复制一份到字符串常量池中；而 JDK 7 及以后因为字符串常量池就在堆上，故是在堆上复制一个引用到字符串常量池中。并且，因为载入基础包等原因，JVM 在加载后，字符串常量池中会默认加载完毕 <code>java</code> 等字符串。</mark></li>
</ol>
<p>值得一提的是，在 JDK 6 以及之前的版本中，静态变量是存放在方法区中的，也就是永久代。JDK 7 及之后的版本中，静态变量是存放在堆中的 Class 对象中，脱离了永久代。</p>
<p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/n70huihui/Blog_Photo/JVM-JDK6%E6%96%B9%E6%B3%95%E5%8C%BA.png"></p>
<p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/n70huihui/Blog_Photo/JVM-JDK7%E6%96%B9%E6%B3%95%E5%8C%BA.png"></p>
<p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/n70huihui/Blog_Photo/JVM-JDK8%E6%96%B9%E6%B3%95%E5%8C%BA.png"></p>
<h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p>直接内存（Direct Memory）并不在《Java 虚拟机规范》中存在，所以<strong>并不属于 Java 运行时的内存区域</strong>，而是由操作系统本地分配的内存区域。在 JDK 1.4 中引入了 NIO 机制，使用了直接内存，主要为了解决以下两个问题：</p>
<ol>
<li>Java 堆中的对象如果不再使用要回收，回收时会影响对象的创建和使用。</li>
<li>IO 操作比如读文件，需要先把文件读入直接内存（缓冲区）再把数据复制到 Java 堆中。现在直接放入直接内存即可，同时 Java 堆上维护直接内存的引用，减少了数据复制的开销。写文件也是类似的思路。</li>
</ol>
<p>要创建直接内存上的数据，可以使用 <code>ByteBuffer</code>，语法（Arthas 的 <code>memory</code> 命令可以直接查看直接内存的大小，属性名 <code>direct</code>）：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ByteBuffer</span> directBuffer <span class="token operator">=</span> <span class="token class-name">ByteBuffer</span><span class="token punctuation">.</span><span class="token function">allocateDirect</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>如果要手动调整直接内存的大小，可以使用 <code>-XX:MaxDirectMemorySize=大小</code>，来为 JVM 的直接内存分配大小。</p>
<h3 id="自动垃圾回收"><a href="#自动垃圾回收" class="headerlink" title="自动垃圾回收"></a>自动垃圾回收</h3><p>在 C/C++ 这类没有自动垃圾回收机制的语言中，一个对象如果不再使用，需要手动释放，否则就会出现<strong>内存泄漏</strong>（内存泄漏的积累可能会导致内存溢出）。我们称这种释放对象的过程为垃圾回收，而需要程序员编写代码进行回收的方式为手动回收。</p>
<p>Java 中为了简化对象的释放，引入了自动的垃圾回收（Garbage Collection 简称 GC）机制。通过垃圾回收器来对不再使用的对象完成自动的回收，垃圾回收器主要负责对堆上的内存进行回收。其他很多现代语言比如 C#、Python、Go 都拥有自己的垃圾回收器。如果想要查看垃圾回收的信息，可以使用 <code>verbose:gc</code> 参数。</p>
<p>线程不共享的部分（程序计数器、Java 虚拟机栈、本地方法栈），都是<strong>伴随着线程的创建而创建，线程的销毁而销毁</strong>。而方法的栈帧在执行完方法之后就会自动弹出栈并释放掉对应的内存。</p>
<h4 id="方法区的回收"><a href="#方法区的回收" class="headerlink" title="方法区的回收"></a>方法区的回收</h4><p>方法区中能回收的内容主要是不再使用的类。判定一个类是否可以被<strong>卸载</strong>（类的声明周期最后一个阶段），需要同时满足三个条件：</p>
<ol>
<li><p>此类所有实例对象都已经被回收，在堆中已经不存在任何该类的实例对象以及子类对象。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> clazz <span class="token operator">=</span> loader<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token string">"cn.hnu.my.A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Object</span> o <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
o <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>加载该类的类加载器已经被回收。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">URLClassLoader</span> loader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">URLClassLoader</span><span class="token punctuation">(</span>
    <span class="token keyword">new</span> <span class="token class-name">URL</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token keyword">new</span> <span class="token class-name">URL</span><span class="token punctuation">(</span><span class="token string">"file:D:\\lib\\"</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
loader <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> clazz <span class="token operator">=</span> loader<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token string">"cn.hnu.my.A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
clazz <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
</ol>
<p>如果需要手动触发垃圾回收，可以调用 <code>System.gc()</code> 方法。调用这个方法并不一定会立即触发垃圾回收，仅仅是向 Java 虚拟机发送一个垃圾回收的请求，具体是否需要执行垃圾回收 Java 虚拟机会自行判断。</p>
<p>开发中此类场景一般很少出现，主要在如 OSGi、JSP 的热部署等应用场景中。每个 jsp 文件对应一个唯一的类加载器，当一个 jsp 文件修改了，就就直接卸载这个 jsp 类加载器。重新创建类加载器，重新加载 jsp 文件。</p>
<h4 id="堆回收"><a href="#堆回收" class="headerlink" title="堆回收"></a>堆回收</h4><p>Java 中的对象是否能被回收，是根据对象是否<strong>被引用</strong>来决定的。如果对象被引用了，说明该对象还在使用，不允许回收。</p>
<p>那如何判断堆上的对象有没有被引用呢？有常见的两种判断方法：引用计数法和可达性分析法。</p>
<h5 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h5><p>引用计数法会为每个对象维护一个引用计数器，当对象被引用时加 1，取消引用时减 1。引用计数法的优点是实现简单，C++ 中的智能指针就采用了引用计数法，但是它也存在缺点，主要有两点：</p>
<ol>
<li>每次引用和取消引用都需要维护计数器，对系统性能造成一定影响。</li>
<li>存在循环引用问题，当 A 中有 B，B 中有 A 的情况下，就会出现 AB 都无法回收的问题。</li>
</ol>
<h5 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h5><p>Java 使用的是<strong>可达性分析算法</strong>来判断对象是否可以被回收。可达性分析将对象分为两类：垃圾回收的根对象（GC Root）和普通对象，对象与对象之间存在引用关系。</p>
<p>所有普通对象都会和根对象形成引用关系，如果某个对象是从 GC Root 沿着引用链可达的，那么对象就不可回收。那么，哪些对象被称之为 GC Root 对象呢？有以下几种：</p>
<ol>
<li>线程 Thread 对象，引用线程栈帧中的方法参数、局部变量等。</li>
<li>系统类加载器加载的 <code>java.lang.Class</code> 对象，引用类中的静态变量。</li>
<li>监视器对象，用来保存同步锁 <code>synchronized</code> 关键字持有的对象。</li>
<li>本地方法调用时使用的全局对象。</li>
</ol>
<h5 id="五种对象引用"><a href="#五种对象引用" class="headerlink" title="五种对象引用"></a>五种对象引用</h5><p>可达性算法中描述的对象引用，一般指的是<strong>强引用</strong>，即是 GC Root 对象对普通对象有引用关系，只要这层关系存在，普通对象就不会被回收。除了强引用之外，Java 中还设计了几种其他引用方式：</p>
<ul>
<li><p>软引用：相对于强引用是一种比较弱的引用关系，如果一个对象只有软引用关联到它，<strong>当程序内存不足时，就会将软引用中的数据进行回收</strong>。在 JDK 1.2 版之后提供了 <code>SoftReference</code> 类来实现软引用，<strong>软引用常用于缓存中</strong>。使用的时候，通过要让 GC Root 来关联 <code>SoftReference</code>：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 将数据放入软引用中</span>
<span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token class-name">SoftReference</span><span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> softReference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>软引用中的对象如果在内存不足时回收，<code>SoftReference</code> 对象本身也需要被回收。如何知道哪些 <code>SoftReference</code> 对象需要回收呢？<code>SoftReference</code> 提供了一套队列机制：</p>
<ol>
<li>软引用创建时，通过构造器传入引用队列。</li>
<li>在软引用中包含的对象被回收时，该软引用对象会被放入引用队列。</li>
<li>通过代码遍历引用队列，将 <code>SoftReference</code> 的强引用删除。</li>
</ol>
<p>软引用也可以使用继承自 <code>SoftReference</code> 类的方式来实现，<code>StudentRef</code> 类就是一个软引用对象。通过构造器传入软引用包含的对象，以及引用队列。</p>
</li>
<li><p>弱引用：弱引用的整体机制和软引用基本一致，区别在于弱引用包含的对象在垃圾回收时，不管内存够不够都会直接被回收。在 JDK 1.2 版之后提供了 <code>WeakReference</code> 类来实现弱引用，弱引用主要在 <code>ThreadLocal</code> 中使用。弱引用对象本身也可以使用引用队列进行回收。</p>
</li>
<li><p>虚引用：也叫幽灵引用 / 幻影引用，不能通过虚引用对象获取到包含的对象。虚引用唯一的用途是当对象被垃圾回收器回收时可以接收到对应的通知。Java 中使用 <code>PhantomReference</code> 实现了虚引用，直接内存中为了及时知道直接内存对象不再使用，从而回收内存，使用了虚引用来实现。（常规开发中不会使用）</p>
</li>
<li><p>终结器引用：结器引用指的是在对象需要被回收时，对象将会被放置在 <code>Finalizer</code> 类中的引用队列中，并在稍后由一条由 <code>FinalizerThread</code> 线程从队列中获取对象，然后执行对象的 <code>finalize</code> 方法。在这个过程中可以在 <code>finalize</code> 方法中再将自身对象使用强引用关联上，但是不建议这样做，如果耗时过长会影响其他对象的回收。（常规开发中不会使用）</p>
</li>
</ul>
<h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><h4 id="算法评判标准"><a href="#算法评判标准" class="headerlink" title="算法评判标准"></a>算法评判标准</h4><p>Java 是如何实现垃圾回收的呢？简单来说，垃圾回收要做的有两件事：</p>
<ol>
<li>使用可达性分析法找到内存中存活的对象。</li>
<li>释放不再存获对象的内存，使得程序能够再次利用这部分空间。</li>
</ol>
<p>1960 年 John McCarthy 发布了第一个 GC 算法：标记 - 清除算法。1963 年 Marvin L. Minsky 发布了复制算法。本质上，后续的所有垃圾回收算法，都是在上述两种算法的基础上优化而来。</p>
<p>Java 垃圾回收过程会通过单独的 GC 线程来完成，但是不管使用哪一种 GC 算法，都会有部分阶段需要停止所<br>有的用户线程。这个过程被称之为 Stop The World 简称 STW，如果 STW 时间过长则会影响用户的使用。</p>
<p>所以，判断 GC 算法是否优秀，可以从三个方面来考虑：</p>
<ol>
<li>吞吐量：吞吐量指的是 CPU 用于执行用户代码的时间与 CPU 总执行时间的比值，即 <code>吞吐量 = 执行用户代码时间 / (执行用户代码时间 + GC时间)</code>。吞吐量数值越高，垃圾回收的效率就越高。</li>
<li>最大暂停时间：最大暂停时间指的是所有在垃圾回收过程中的 STW 时间最大值。最大暂停时间越短，用户使用系统时受到的影响就越短。</li>
<li>堆使用效率：不同垃圾回收算法，对堆内存的使用方式是不同的。比如标记清除算法，可以使用完整的堆内存。而复制算法会将堆内存一分为二，每次只能使用一半内存。从堆使用效率上来说，标记清除算法要优于复制算法。</li>
</ol>
<p>上述三种评价标准：堆使用效率、吞吐量，以及最大暂停时间不可兼得。一般来说，堆内存越大，最大暂停时间就越长。想要减少最大暂停时间，就会降低吞吐量。不同的垃圾回收算法，适用于不同的场景。</p>
<h4 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h4><p>标记清除算法的核心思想分为两个阶段：</p>
<ol>
<li>标记阶段，将所有存活的对象进行标记。Java 使用可达性分析算法，从 GC Root 开始通过引用链遍历出所有存活对象。</li>
<li>清除阶段，从内存中删除没有被标记的，也就是非存活的对象。</li>
</ol>
<p>优点：实现简单，只需要在第一阶段给每个对象维护标志位，第二阶段删除对象即可。</p>
<p>缺点：</p>
<ol>
<li>碎片化问题：由于内存是连续的，所以在对象被删除之后，内存中会出现很多细小的可用内存单元。如果我们需要的是一个比较大的空间，很有可能这些内存单元的大小过小无法进行分配。</li>
<li>分配速度慢：由于内存碎片的存在，需要维护一个空闲链表，极有可能发生每次需要遍历到链表的最后才<br>能获得合适的内存空间。</li>
</ol>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>复制算法的核心思想是：</p>
<ol>
<li>准备两块空间 From 和 To，每次在对象分配阶段，只能使用其中一块空间（From 空间）。</li>
<li>在垃圾回收 GC 阶段，将 From 中存活对象复制到 To 空间。</li>
<li>将两块空间的名字互换（保证对象只存在于 From 空间）。</li>
</ol>
<p>优点：</p>
<ol>
<li>吞吐量高：复制算法只需要遍历一次存活对象复制到 To 空间即可，比标记-整理算法少了一次遍历的过程，因而性能较好，但是不如标记-清除算法因为标记清除算法不需要进行对象的移动。</li>
<li>不会发生碎片化：复制算法在复制之后就会将对象按顺序放入 To 空间中，所以对象以外的区域都是可用空间，不存在碎片化内存空间。</li>
</ol>
<p>缺点：内存使用效率低，每次只能让一般的内存空间来为创建对象使用。</p>
<h4 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h4><p>标记整理算法也叫标记压缩算法，是对标记清理算法中容易产生内存碎片问题的一种解决方案。</p>
<p>核心思想分为两个阶段：</p>
<ol>
<li>标记阶段，将所有存活的对象进行标记。Java 中使用可达性分析算法，从 GC Root 开始通过引用链遍历出<br>所有存活对象。</li>
<li>整理阶段，将存活对象移动到堆的一端。清理掉存活对象的内存空间。</li>
</ol>
<p>优点：</p>
<ol>
<li>内存使用率高：整个堆内存都可以使用，不会像复制算法只能用半个堆内存。</li>
<li>不会发生碎片化：在整理阶段可以将对象往内存的一侧进行移动，剩下的空间都是可以分配对象的有效空间。</li>
</ol>
<p>缺点：整理阶段的效率不高，整理算法有很多种，比如 Lisp2 整理算法需要对整个堆中的对象搜索 3 次，整体性能不佳。可以通过 Two-Finger、表格算法、ImmixGC 等高效的整理算法优化此阶段的性能。</p>
<h4 id="分代垃圾回收算法"><a href="#分代垃圾回收算法" class="headerlink" title="分代垃圾回收算法"></a>分代垃圾回收算法</h4><p>现代优秀的垃圾回收算法，会将上述描述的垃圾回收算法组合进行使用，其中应用最广的就是分代垃圾回收<br>算法（Generational GC）。</p>
<p>分代垃圾回收将整个内存区域划分为年轻代（Young）和老年代（Old）：Yong 区存放存活时间比较短的对象，Old 区存放存活时间比较长的对象。</p>
<p>进一步，Yong 区又会划分成几个区域：</p>
<ul>
<li>伊甸园区（Eden）：对象刚刚被创建时会存放在这里。</li>
<li>幸存者区（Survivor 0 和 Survivor 1，一共两个区，也就是 From 和 To 区）：用来实现复制算法。</li>
</ul>
<p>在 JDK 8 中，添加 <code>-XX:+UserSerialGC</code> 参数使用分代回收的垃圾回收器，运行程序。在 Arthas 中使用 <code>memory</code> 命令查看内存，显示出上述几个区域的使用情况。</p>
<p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/n70huihui/Blog_Photo/JVM-%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.png"></p>
<p>分代回收时，创建出来的对象，首先会被放入 Eden 区。随着对象在 Eden 区越来越多，如果 Eden 区满，新创建的对象已经无法放入，就会触发年轻代的 GC，称为 Minor GC 或者 Young GC。Minor GC 会把 Eden 区和 From 区需要回收的对象回收，把没有回收的对象放入 To 区。</p>
<p>接下来，From 区会变成 To 区，To 区会变成 From 区。当 Eden 区满时再往里放入对象，依然会发生 Minor GC。每次 Minor GC 都会为存活对象记录年龄，初始值为 0，每次完成 GC，就会加 1。</p>
<p>如果 Minor GC 后对象的年龄达到阈值(最大 15，默认值和垃圾回收器有关)，对象就会被晋升到老年代。老年代一般不会触发 GC，因为这里的对象被认为是经常使用，无需回收 （比如 Spring 的大部分 Bean 对象）。</p>
<p>当老年代空间不足，无法放入新对象时，JVM 会先尝试 Minor GC。如果还是空间不够，再去触发 Full GC，对整个堆进行垃圾回收。</p>
<h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><p>垃圾回收器是垃圾回收算法的具体实现。</p>
<p>由于垃圾回收器分为年轻代和老年代，除了 G1 之外其他垃圾回收器必须成对组合进行使用。具体关系图如下：</p>
<p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/n70huihui/Blog_Photo/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.png"></p>
<h4 id="Serial-垃圾回收器"><a href="#Serial-垃圾回收器" class="headerlink" title="Serial 垃圾回收器"></a>Serial 垃圾回收器</h4><p>Serial 是一种<strong>单线程串行回收</strong>的年轻代的垃圾回收器。如果年轻代的 Eden 区满了，Serial 回收器会使用复制算法，暂停用户线程，对 Eden 区和 From 区进行回收。</p>
<ul>
<li><p>优点：单 CPU 处理器下吞吐量非常出色。</p>
</li>
<li><p>缺点：多 CPU 下吞吐量不如其他垃圾回收器，堆如果偏大会让用户线程处于长时间的等待。</p>
</li>
<li><p>使用场景：Java 编写的客户端程序或者硬件配置有限的场景。</p>
</li>
</ul>
<p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/n70huihui/Blog_Photo/JVM-Serial%E5%9B%9E%E6%94%B6%E5%99%A8.png"></p>
<h4 id="SerialOld-垃圾回收器"><a href="#SerialOld-垃圾回收器" class="headerlink" title="SerialOld 垃圾回收器"></a>SerialOld 垃圾回收器</h4><p>SerialOld 垃圾回收器是 Serial 回收器的老年代版本，也是<strong>采用单线程进行回收</strong>。其针对老年代区使用的回收算法是标记 - 整理算法。使用 <code>-XX:+UseSerialGC</code> 可以让新生代、老年代都是用串行回收器。</p>
<ul>
<li><p>优点：单 CPU 处理器下吞吐量非常出色。</p>
</li>
<li><p>缺点：多 CPU 下吞吐量不如其他垃圾回收器，堆如果偏大会让用户线程处于长时间的等待。</p>
</li>
<li><p>使用场景：与 Serial 垃圾回收器搭配使用，或者在 CMS 特殊情况下使用。</p>
</li>
</ul>
<h4 id="ParNew-垃圾回收器"><a href="#ParNew-垃圾回收器" class="headerlink" title="ParNew 垃圾回收器"></a>ParNew 垃圾回收器</h4><p>ParNew 本质上是对 Serial 在多 CPU 下的优化，使用<strong>多线程</strong>进行垃圾回收。其针对年轻代区使用复制算法进行回收。使用 <code>-XX:+UseParNewGC</code> 可以让新生代使用 ParNew 回收器，老年代使用串行回收器。</p>
<ul>
<li>优点：多 CPU 处理器下停顿时间较短。</li>
<li>缺点：吞吐量和停顿时间不如 G1，所以在 JDK 9 之后不建议使用。</li>
<li>使用场景：JDK 8 及之前的版本中，与 CMS 老年代回收器搭配使用。</li>
</ul>
<p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/n70huihui/Blog_Photo/JVM-ParNew%E5%9B%9E%E6%94%B6%E5%99%A8.png"></p>
<h4 id="CMS-垃圾回收器"><a href="#CMS-垃圾回收器" class="headerlink" title="CMS 垃圾回收器"></a>CMS 垃圾回收器</h4><p>CMS 垃圾回收器关注的是系统的<strong>暂停时间</strong>，允许用户线程和垃圾回收线程在某些步骤中<strong>同时执行</strong>，减少用户线程的等待时间。其针对老年代区执行标记清除算法。参数：<code>-XX:+UseConcMarkSweepGC</code>。</p>
<ul>
<li>优点：系统由于垃圾回收出现的停顿时间较短，用户体验好。</li>
<li>缺点：内存碎片问题，退化问题，浮动垃圾问题。</li>
<li>使用场景：大型的互联网系统中用户请求数据量大、频率高的场景。比如订单接口、商品接口等。</li>
</ul>
<p>CMS 执行步骤：</p>
<ol>
<li>初始标记：用极短的时间标记处 GC Root 能直接关联到的对象。（单线程）</li>
<li>并发标记：标记所有的对象，用户线程不需要暂停。（多线程）</li>
<li>重新标记：由于并发标记阶段有些对象会发生变化，存在错标、漏标等情况，需要重新标记。（单线程）</li>
<li>并发清理：清理死亡对象，用户线程不需要暂停。（多线程）</li>
</ol>
<p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/n70huihui/Blog_Photo/JVM-CMS%E5%9B%9E%E6%94%B6%E5%99%A8.png"></p>
<p>并发的处理使得两个单线程操作时间会下降，总体的系统暂停时间也会有所降低。如果老年代内存不足无法分配对象，CMS 就会退化成 SerialOld 单线程回收老年代。</p>
<h4 id="Parallel-Scavenge-垃圾回收器"><a href="#Parallel-Scavenge-垃圾回收器" class="headerlink" title="Parallel Scavenge 垃圾回收器"></a>Parallel Scavenge 垃圾回收器</h4><p>Parallel Scavenge 是 JDK 8 默认的年轻代垃圾回收器，<strong>多线程并行</strong>回收，关注的是系统的<strong>吞吐量</strong>。具备<strong>自动调整堆内存大小</strong>的特点。针对年轻代使用复制算法。参数：<code>-XX:+UseParallelGC</code>。</p>
<ul>
<li>优点：吞吐量高，而且手动可控。为了提高吞吐量，JVM 会动态调整堆的参数。</li>
<li>缺点：不能保证单次的停顿时间。</li>
<li>使用场景：后台任务，不需要与用户交互，并且容易产生大量的对象。比如：大数据的处理，大文件导出。</li>
</ul>
<p>Oracle 官方建议在使用 Parallel Scavenge 和 Parallel Old 这个组合的时候，<strong>不要设置堆内存的最大值</strong>，垃圾回收器会根据最大暂停时间和吞吐量自动调整堆内存大小。</p>
<ul>
<li>最大暂停时间：<code>-XX:MaxGCPauseMillis=n</code>，设置每次垃圾回收时的最大停顿毫秒数。</li>
<li>吞吐量：<code>-XX:GCTimeRatio=n</code>，设置吞吐量为 n（<code>用户线程执行时间 = n / n + 1</code>）。</li>
<li>自动调整内存大小：<code>-XX:+UseAdaptiveSizePolicy</code> 设置可以让垃圾回收器根据吞吐量和最大停顿的毫秒数自动调整内存大小。</li>
</ul>
<p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/n70huihui/Blog_Photo/JVM-PS%E5%9B%9E%E6%94%B6%E5%99%A8.png"></p>
<h4 id="Parallel-Old-垃圾回收器"><a href="#Parallel-Old-垃圾回收器" class="headerlink" title="Parallel Old 垃圾回收器"></a>Parallel Old 垃圾回收器</h4><p>Parallel Old 是为 Parallel Scavenge 设计的老年代版本，利用<strong>多线程并发</strong>回收。对老年代区域使用标记 - 整理算法。参数：<code>-XX:+UseParallelOldGC</code>。</p>
<ul>
<li>优点：并发执行，在多核 CPU 下效率较高。</li>
<li>缺点：暂停时间会比较长。</li>
<li>使用场景：与 Parallel Scavenge 配套使用。</li>
</ul>
<h4 id="G1-垃圾回收器"><a href="#G1-垃圾回收器" class="headerlink" title="G1 垃圾回收器"></a>G1 垃圾回收器</h4><p>JDK 9 之后默认的垃圾回收器就是 G1（Garbage First）垃圾回收器。</p>
<p>Parallel Scavenge 关注吞吐量，允许用户设置最大暂停时间，但是会减少年轻代可用的空间大小。</p>
<p>CMS 关注暂停时间，但是吞吐量会下降。</p>
<p>而 G1 的设计目标就是将上述两种垃圾回收器的优点融合：</p>
<ol>
<li>支持巨大的堆空间回收，并有较高的吞吐量。</li>
<li>支持多 CPU 并行垃圾回收。</li>
<li>允许用户设置最大暂停时间。</li>
</ol>
<p>G1 回收器对堆空间进行了重新划分：G1 的整个堆会被划分成多个大小相等的区域，称之为区 Region，区域不要求是连续的。分为 Eden、Survivor、Old 区。Region 的大小通过 <code>堆空间大小 / 2048</code> 计算得到，也可以通过参数 <code>-XX:G1HeapRegionSize=32m</code> 指定（其中 32 m 指定 region 大小为 32 M），Region size 必须是 2 的指数幂，取值范围从 1 M 到 32 M。</p>
<p>G1 垃圾回收有两种方式：</p>
<ol>
<li><p>年轻代回收（Young GC）：回收 Eden 和 Survivor 中不用的对象，回导致 STW，G1 可以通过参数 <code>-XX:MaxGCPauseMillis=n</code>（默认 200）设置每次垃圾回收的最大暂停时间毫秒数，G1 垃圾回收器会尽可能地保证暂停时间。</p>
<p>创建的对象会存放在 Eden 区。当 G1 判断年轻代区不足（max 默认 60%），无法分配对象时需要回收时会执行 Young GC：标记出 Eden 和 Survivor 区域中的存活对象，根据配置的最大暂停时间选择某些区域将存获对象复制到一个新的 Survivor 区中（年龄 + 1），清空这些区域。</p>
<p>G1 在进行 Young GC 的过程中会去记录每次垃圾回收时每个 Eden 区和 Survivor 区的平均耗时，以作为下次回收时的参考依据。这样就可以根据配置的最大暂停时间计算出本次回收时最多能回收多少个 Region 区域了。<br>比如 <code>-XX:MaxGCPauseMillis=n</code>（默认200），每个 Region 回收耗时 40 ms，那么这次回收最多只能回收 4 个 Region。</p>
<p>后续 Young GC 时与之前相同，只不过 Survivor 区中存活对象会被搬运到另一个 Survivor 区。当某个存活对象的年龄达到阈值（默认 15），将被放入老年代。部分对象如果大小超过 Region 的一半，会直接放入老年代，这类老年代被称为 Humongous 区。</p>
<p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/n70huihui/Blog_Photo/JVM-G1%E5%9B%9E%E6%94%B6%E5%99%A8.png"></p>
</li>
<li><p>混合回收（Mixed GC）：多次回收后，会出现很多 Old 老年代区，此时总堆占有率达到阈值时（<code>-XX:initiatingHeapOccupancyPercent</code> 默认为 45%）会触发混合回收 Mixed GC。回收所有年轻代和部分老年代的对象以及大对象区。采用复制算法完成。</p>
<p>混合回收分为：初始标记（标记 GC Root 引用的对象为存活）、并发标记（将第一步中标记的对象引用的对象标记为存活）、最终标记（标记一些引用改变漏标的对象，不管新创建、不再关联的对象）、并发清理（将存活对象复制到别的 Region，不会产生内存碎片）。</p>
<p>G1 对老年代的清理会选择存货度最低的区域来进行回收，这样可以保证回收效率最高，这也是 G1（Garbage First）名字的由来。如果清理过程中发现没有足够的空 Region 存放转移的对象，会出现 Full GC。<strong>单线程</strong>执行标记-整理算法，<strong>此时会导致用户线程的暂停</strong>。所以尽量保证应该用的堆内存有一定多余的空间。</p>
<p><img src="/medias/loading.gif" data-original="https://cdn.jsdelivr.net/gh/n70huihui/Blog_Photo/JVM-G1%E6%B7%B7%E5%90%88%E5%9B%9E%E6%94%B6.png"></p>
</li>
</ol>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">热心市民灰灰</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://example.com/2024/08/18/jvm/">http://example.com/2024/08/18/jvm/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">热心市民灰灰</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/Java/">
                                    <span class="chip bg-color">Java</span>
                                </a>
                            
                                <a href="/tags/JVM/">
                                    <span class="chip bg-color">JVM</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2024/09/09/springcloud/">
                    <div class="card-image">
                        
                        <img src="/medias/loading.gif" data-original="/medias/featureimages/SpringCloud.jpg" class="responsive-img" alt="SpringCloud">
                        
                        <span class="card-title">SpringCloud</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            SpringCloud相关内容
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2024-09-09
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/SpringCloud/" class="post-category">
                                    SpringCloud
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Java/">
                        <span class="chip bg-color">Java</span>
                    </a>
                    
                    <a href="/tags/SpringCloud/">
                        <span class="chip bg-color">SpringCloud</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2024/08/12/springai/">
                    <div class="card-image">
                        
                        <img src="/medias/loading.gif" data-original="/medias/featureimages/SpringAI.jpg" class="responsive-img" alt="SpringAI">
                        
                        <span class="card-title">SpringAI</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            SpringAI相关内容
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2024-08-12
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/SpringAI/" class="post-category">
                                    SpringAI
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Java/">
                        <span class="chip bg-color">Java</span>
                    </a>
                    
                    <a href="/tags/SpringAI/">
                        <span class="chip bg-color">SpringAI</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="2106933454"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2023-2025</span>
            
            <span id="year">2023</span>
            <a href="/about" target="_blank">热心市民灰灰</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">437.2k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2023";
                    var startMonth = "8";
                    var startDate = "8";
                    var startHour = "0";
                    var startMinute = "0";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站竟然运行了 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站竟然运行了 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/n70huihui" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:2744136107@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=2744136107" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 2744136107" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

	
    

    

    
    <script type="text/javascript" src="/libs/background/ribbon-dynamic.js" async="async"></script>
    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/22.2017.summer.normal.2.model.json"},"display":{"position":"left","width":225,"height":450},"mobile":{"show":true},"log":false});</script>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,c=(r.imageLazyLoadSetting.preloadRatio,n());function n(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=n());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight+240||document.documentElement.clientHeight+240)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function a(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",a),r.addEventListener("resize",a),r.addEventListener("orientationchange",a)}(this);</script></body>

</html>
